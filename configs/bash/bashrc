# ! bashrc is read by non-login shells, bash_profile is read by login shells
# ! Keep in here options, history, aliases, prompt, etc.

# If not running interactively, don't do anything
case $- in
  *i*) ;;
    *) return;;
esac

# ## Configs
# ## ===================================================================================

# Enable vi mode, gets activated when pressing `esc`
set -o vi

# Check the window size after each command and update the LINES and COLUMNS variables
shopt -s checkwinsize

# Append to history, don't overwrite it, this is combined with `$PROMPT_COMMAND` below
# and readline config in `.inputrc` to make sure history is always up to date
shopt -s histappend

# https://mywiki.wooledge.org/glob
# An unmatched glob expands to nothing instead of staying literal. Not POSIX.
# Enabling this can lead to unexpected behavior, e.g., `ls *nonexistent*` will list all the 
# contents of the dir (because the glob expansion expanded to empty).
# shopt -s nullglob
# An unmatched glob becomes an error. It has edge cases too.
# shoot -s failglob

# ## Exports
# ## ===================================================================================

# Big history
export HISTSIZE=100000
export HISTFILESIZE=150000
# Ignore commands starting with space, duplicate, and erased duplicates
export HISTCONTROL=ignorespace:ignoredups:erasedups

# Append new commands to history file and read new commands from history file,
# this is combined with `shopt -s histappend` above and readline config (`.inputrc`).
# But only add history sync once
case "$PROMPT_COMMAND" in
  *"history -a; history -n;"*) ;;
  *) export PROMPT_COMMAND="history -a; history -n; ${PROMPT_COMMAND}" ;;
esac

# ## Aliases
# ## ===================================================================================

if [ -f ~/.bash_aliases ]; then
  source ~/.bash_aliases
fi

# ## Prompt
# ## ===================================================================================

# Two-line prompt with per-piped command exit codes

# ANSI colors (wrapped as non-printing for bash/readline)
__c_reset='\[\033[0m\]'
# Using 91/92/94 instead of 31/32/34 to prevent the "bold" effect
__c_red='\[\033[0;91m\]'
__c_green='\[\033[0;92m\]'  # Debian-style green
__c_blue='\[\033[0;94m\]'   # Debian-style blue

__set_prompt() {
  # Build: [ 0 | 127 | 0 ] with 0=green, nonzero=red
  local -a ps=( "${PIPESTATUS[@]}" )
  local out="{" i code color

  for i in "${!ps[@]}"; do
    code="${ps[i]}"
    color="$__c_green"
    [[ "$code" != 0 ]] && color="$__c_red"

    if (( i == 0 )); then
      out+=" ${color}${code}${__c_reset}"
    else
      out+=" | ${color}${code}${__c_reset}"
    fi
  done
  out+=" }"

  # Root styling
  local user_color="$__c_green"
  local prompt_color=""
  if (( EUID == 0 )); then
    user_color="$__c_red" # username red if root
    prompt_color="$__c_red" # make "# " red
  fi
  
  # Conda env indicator
  local conda_env="${CONDA_DEFAULT_ENV:+ (${CONDA_DEFAULT_ENV})}"

  # Line 1: [ ... ] username@host cwd
  #   - username: green (or red if root)
  #   - @host: green
  #   - cwd: blue
  # Line 2: $  (or red # if root)
  PS1="${out}${conda_env} ${user_color}\u${__c_green}${__c_reset} @ ${__c_green}\h${__c_reset} ${__c_blue}\w${__c_reset}\n${prompt_color}\$${__c_reset} "
}

case "$PROMPT_COMMAND" in
  *"__set_prompt"*) ;;
  "") PROMPT_COMMAND="__set_prompt" ;;
  *) PROMPT_COMMAND="__set_prompt; ${PROMPT_COMMAND}" ;;
esac
